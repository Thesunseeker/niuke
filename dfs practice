
#include <iostream>
#include <string>
#include <vector>
#include <stack>
#include <algorithm>
#include <ctype.h> 
using namespace std;

void Dfs(int index, int n ,vector<int> &boxs, vector<int> &books)
{
	if (index == n + 1)
	{
		for (int i = 0; i <= n; i++)
		{
			cout << boxs[i] << " " << endl;
			return;
		}
	}
	for (int i = 0; i <= n; i++)
	{
		if (books[i] == 0)
		{
			boxs[index] = i;
			books[i] = 1;

			Dfs(index + 1, n, boxs, books);

			books[i] = 0;
		}
	}
}

int main()
{
	int n;
	vector<int> boxs;
	vector<int> books;
	cin >> n;
	boxs.resize(n + 1, 0);
	books.resize(n + 1, 0);
	Dfs(1, n, boxs, books);
	return 0;
}

äºŒ:https://leetcode-cn.com/problems/flood-fill/submissions/
int nextPosition[4][2] = { {0 , 1}, {1 , 0}, { 0 , -1} , { -1 , 0} };
class Solution {
public:
    void dfs(vector<vector<int>> &image, int row , int col , vector<vector<int>> &book , int sr , int sc , 
    int oldColor , int newColor)
    {
        image[sr][sc] = newColor;
        book[sr][sc] = 1;
        for(int i = 0; i < 4; ++i)
        {
            int newsr = sr + nextPosition[i][0];
            int newsc = sc + nextPosition[i][1];
            if(newsr >= row || newsr < 0 || newsc >= col || newsc < 0)
                continue;
            if(image[newsr][newsc] == oldColor && book[newsr][newsc] == 0)
            {
                dfs(image , row , col , book , newsr , newsc , oldColor , newColor);
            }
        }
    }

    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) 
    {
        if(image.empty())
            return image;
        int col = image[0].size();
        int row = image.size();

        vector<vector<int>> book;
        book.resize(row);
        for(int i = 0; i < row; i++)
        {
            book[i].resize(col,0);
        }    

        int oldColor = image[sr][sc];
        dfs(image , row , col , book , sr , sc , oldColor , newColor);
        return image;
    }
};
